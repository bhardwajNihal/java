Pattern-Wise Standard LeetCode Questions to Practice
Practicing LeetCode questions by pattern is highly effective. Here are some common patterns and classic problems associated with them.

1. Two Pointers
Used for problems involving sorted arrays or linked lists, often to find pairs, triplets, or to modify elements in-place.

Concept: Two pointers (or indices) traverse the data structure, often from opposite ends or at different speeds.

Examples:

[Easy] 1. Two Sum (variation: unsorted array, use hash map)

[Easy] 167. Two Sum II - Input Array Is Sorted

[Easy] 283. Move Zeroes

[Medium] 11. Container With Most Water

[Medium] 15. 3Sum

[Medium] 42. Trapping Rain Water

[Easy] 19. Remove Nth Node From End of List (Fast and Slow Pointers)

[Easy] 141. Linked List Cycle (Fast and Slow Pointers)

2. Sliding Window
Useful for problems involving subarrays or substrings, where you need to maintain a "window" of elements and slide it across the data.

Concept: Maintain a dynamic window (can expand or shrink) over a portion of a sequence (array/string) to efficiently solve problems involving contiguous sub-sequences.

Examples:

[Medium] 3. Longest Substring Without Repeating Characters

[Medium] 424. Longest Repeating Character Replacement

[Medium] 209. Minimum Size Subarray Sum

[Medium] 76. Minimum Window Substring

[Medium] 567. Permutation in String

3. Fast & Slow Pointers (Floyd's Cycle-Finding Algorithm)
Specifically for linked lists or problems where you need to detect cycles or find specific points in a sequence.

Concept: Two pointers move at different speeds (one fast, one slow) to detect cycles, find the middle, or find the start of a cycle.

Examples:

[Easy] 141. Linked List Cycle

[Medium] 142. Linked List Cycle II (Find the start of the cycle)

[Medium] 876. Middle of the Linked List

[Hard] 234. Palindrome Linked List (Can be solved by reversing half and comparing)

4. Merge Intervals
Problems involving overlapping intervals where you need to merge them or find non-overlapping ones.

Concept: Sort intervals by start time and then iterate, merging if overlaps occur.

Examples:

[Medium] 56. Merge Intervals

[Medium] 57. Insert Interval

[Medium] 986. Interval List Intersections

5. Cyclic Sort
Applicable to problems dealing with arrays containing numbers in a specific range (e.g., 1 to N).

Concept: If numbers are in a range [1,N] or [0,N−1], you can place each number at its correct sorted position.

Examples:

[Easy] 268. Missing Number

[Easy] 448. Find All Numbers Disappeared in an Array

[Medium] 41. First Missing Positive

[Medium] 287. Find the Duplicate Number

6. In-place Reversal of a Linked List
When you need to reverse a linked list or parts of it without using extra space.

Concept: Iteratively change the next pointers of nodes to reverse the direction.

Examples:

[Easy] 206. Reverse Linked List

[Medium] 92. Reverse Linked List II

[Medium] 25. Reverse Nodes in k-Group

7. Tree BFS (Level Order Traversal)
For problems where you need to traverse a tree level by level. Uses a queue.

Concept: Visit all nodes at the current depth level before moving to the next depth level.

Examples:

[Easy] 102. Binary Tree Level Order Traversal

[Medium] 107. Binary Tree Level Order Traversal II

[Medium] 103. Binary Tree Zigzag Level Order Traversal

[Medium] 199. Binary Tree Right Side View

[Easy] 104. Maximum Depth of Binary Tree

8. Tree DFS (Preorder, Inorder, Postorder)
For problems where you need to traverse a tree deeply along one path before backtracking. Uses recursion (or an explicit stack).

Concept: Explore as far as possible along each branch before backtracking.

Examples:

[Easy] 94. Binary Tree Inorder Traversal

[Easy] 144. Binary Tree Preorder Traversal

[Easy] 145. Binary Tree Postorder Traversal

[Medium] 98. Validate Binary Search Tree

[Medium] 230. Kth Smallest Element in a BST

[Medium] 105. Construct Binary Tree from Preorder and Inorder Traversal

9. Two Heaps
Useful for problems where you need to maintain two halves of a sorted data set (e.g., finding the median).

Concept: Use a max-heap for the first half and a min-heap for the second half to keep track of relative order and efficiently retrieve elements like the median.

Examples:

[Hard] 295. Find Median from Data Stream

[Medium] 502. IPO

10. Subsets / Combinations / Permutations (Backtracking)
Classic backtracking problems exploring all possible combinations or sequences.

Concept: Recursively build a solution, one element at a time, and "backtrack" (undo the choice) if it doesn't lead to a valid solution.

Examples:

[Medium] 78. Subsets

[Medium] 90. Subsets II

[Medium] 46. Permutations

[Medium] 47. Permutations II

[Medium] 39. Combination Sum

[Medium] 40. Combination Sum II

[Hard] 51. N-Queens

11. Dynamic Programming
Problems that can be broken down into overlapping subproblems and exhibit optimal substructure.

Concept: Solve smaller subproblems and store their results to avoid redundant computations when solving larger problems.

Examples:

[Easy] 70. Climbing Stairs

[Easy] 198. House Robber

[Easy] 121. Best Time to Buy and Sell Stock

[Medium] 53. Maximum Subarray

[Medium] 300. Longest Increasing Subsequence

[Medium] 64. Minimum Path Sum

[Medium] 5. Longest Palindromic Substring

[Medium] 322. Coin Change

[Hard] 10. Regular Expression Matching

[Hard] 44. Wildcard Matching

12. Graph Traversal (BFS/DFS)
Fundamental for problems on graphs (networks) or matrix/grid problems that can be modeled as graphs.

Concept: Explore nodes and edges of a graph. BFS for shortest paths on unweighted graphs, DFS for connectivity, cycle detection, etc.

Examples:

[Medium] 200. Number of Islands

[Medium] 994. Rotting Oranges (BFS)

[Medium] 133. Clone Graph (BFS/DFS)

[Medium] 785. Is Graph Bipartite?

[Medium] 695. Max Area of Island

[Medium] 733. Flood Fill

13. Topological Sort
For Directed Acyclic Graphs (DAGs) where tasks have dependencies.

Concept: Linear ordering of vertices such that for every directed edge u→v, vertex u comes before v in the ordering.

Examples:

[Medium] 207. Course Schedule

[Medium] 210. Course Schedule II

[Hard] 269. Alien Dictionary (if given in a contest)

14. K-way Merge / Top 'K' Elements (Heaps/Priority Queues)
Problems requiring merging sorted lists or finding the K smallest/largest elements.

Concept: Use a min-heap (for smallest) or max-heap (for largest) to efficiently get the top/bottom k elements. For merging sorted lists, a min-heap stores the smallest element from each list.

Examples:

[Medium] 23. Merge k Sorted Lists

[Medium] 215. Kth Largest Element in an Array

[Medium] 347. Top K Frequent Elements

[Medium] 703. Kth Largest Element in a Stream

15. Binary Search on Answer
When the answer to a problem lies within a range and you can check if a given value is a possible answer.

Concept: Instead of searching for an element, binary search can be used to search for the answer itself when the "check" function for a potential answer is monotonic.

Examples:

[Medium] 4. Median of Two Sorted Arrays

[Medium] 875. Koko Eating Bananas

[Medium] 1011. Capacity To Ship Packages Within D Days

[Medium] 162. Find Peak Element

16. Union-Find (Disjoint Set Union)
For problems involving connected components in graphs or managing sets of elements.

Concept: Efficiently determine if two elements are in the same set and merge sets.

Examples:

[Medium] 547. Number of Provinces

[Medium] 721. Accounts Merge

[Medium] 1202. Smallest String With Swaps

[Hard] 684. Redundant Connection

17. Trie (Prefix Tree)
For problems involving string prefixes, searching words, or autocomplete.

Concept: A tree-like data structure where nodes store characters and paths represent words.

Examples:

[Medium] 208. Implement Trie (Prefix Tree)

[Medium] 211. Design Add and Search Words Data Structure

[Hard] 212. Word Search II